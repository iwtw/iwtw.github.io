[{"title":"vsftpd配置","date":"2017-04-17T06:53:09.000Z","path":"2017/04/17/vsftpd配置/","text":"安装1sudo apt-get install vsftpd 设置配置文件1$sudo vim /etc/vsftpd.conf #也可能是/etc/vsfptd/vsftpd.conf 设置write_enable=YESlocal_enable=YES然后重启1$sudo service vsftpd restart 一般到这里就可以了,然而今天在实验室的机房(环境为RedHat),还出现550和553的问题,那么继续 RedHat设置Sebool虚拟机上的RedHat Linux7 vsfptd出现553 Could not create file的解决方法","tags":[{"name":"vsftpd","slug":"vsftpd","permalink":"http://yoursite.com/tags/vsftpd/"},{"name":"ftp","slug":"ftp","permalink":"http://yoursite.com/tags/ftp/"}]},{"title":"additional relocation overflows omitted from the output","date":"2017-04-17T03:45:19.000Z","path":"2017/04/17/additional-relocation-overflows-omitted-from-the-output/","text":"g++的内存模型默认使用small,当预分配的静态数组内存大于2GB时,会出现如题所述报错,这时候需要使用medium内存模型编译时加上选项:-mcmodel=medium拓展:编译分为几种编译模式(挖坑待填)","tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"},{"name":"compile","slug":"compile","permalink":"http://yoursite.com/tags/compile/"},{"name":"g++","slug":"g","permalink":"http://yoursite.com/tags/g/"},{"name":"overflow","slug":"overflow","permalink":"http://yoursite.com/tags/overflow/"}]},{"title":"生成模型(generative)和判别模型(discriminative)的区别","date":"2017-04-12T03:20:08.000Z","path":"2017/04/12/生成模型-generative-和判别模型-discriminative-的区别/","text":"生成模型和判别模型","tags":[{"name":"generative model","slug":"generative-model","permalink":"http://yoursite.com/tags/generative-model/"},{"name":"discriminative model","slug":"discriminative-model","permalink":"http://yoursite.com/tags/discriminative-model/"},{"name":"probability theory","slug":"probability-theory","permalink":"http://yoursite.com/tags/probability-theory/"}]},{"title":"使用Privoxy为终端走ShadowSocks代理","date":"2017-04-11T06:45:27.000Z","path":"2017/04/11/使用Privoxy为终端走ShadowSocks代理/","text":"ShadowSocks命令行版安装1$pip install shadowsocks ShadowSocks命令行版使用首先写配置文件config.json12345678910&#123; \"server\":\"servername\", \"server_port\":serverport, \"local_address\":\"127.0.0.1\", \"local_port\":1080, \"password\":\"password\", \"timeout\":300, \"method\":\"aes-256-cfb\", \"fast_open\":true //这个功能只支持Linux3.7以上&#125; 然后创建两个空白文件,用于存shadowsocks守护进程的日志和pid12$touch log$touch shadowsocks.pid 创建一个start.sh用于启动SS daemon12#!/bin/bashsslocal -d start -c /home/wutingwei/shadowsocks/config.json --log-file /home/wutingwei/shadowsocks/log --pid-file /home/wutingwei/shadowsocks/shadowsocks.pid stop守护进程只要把上面的start改成stop，注意使用同一个pid文件 使用Privoxy为终端走SS代理ss使用的是socks5协议，而终端要走代理的话，必须使用http/https协议，因此需要协议转换，我们使用Privoxy作协议转换参考:使用Privoxy将socks5代理转为http代理","tags":[{"name":"VPN","slug":"VPN","permalink":"http://yoursite.com/tags/VPN/"},{"name":"终端代理","slug":"终端代理","permalink":"http://yoursite.com/tags/终端代理/"},{"name":"socks5","slug":"socks5","permalink":"http://yoursite.com/tags/socks5/"},{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"},{"name":"https","slug":"https","permalink":"http://yoursite.com/tags/https/"},{"name":"privoxy","slug":"privoxy","permalink":"http://yoursite.com/tags/privoxy/"},{"name":"shadowsocks","slug":"shadowsocks","permalink":"http://yoursite.com/tags/shadowsocks/"}]},{"title":"经纬度和地图坐标的转换","date":"2017-04-07T12:23:34.000Z","path":"2017/04/07/经纬度和地图坐标的转换/","text":"吐槽百度的“批量”坐标转换一次最多只支持10个点的转换！demo上还不作说明！而且是以回调函数的方式获得转换后的BMap.Point[]！也就是说如果你要给每个点按顺序贴标签是做不到的！因为回调函数是异步调用的，WTF！！！！已身中javascript剧毒… 于是我转向高德地图，卧槽，高德地图连转换API都没有，一查才涨了关于中国地图坐标系的姿势 地球坐标系，火星坐标系，百度地图坐标系美国GPS定位采用的坐标系叫做WGS-84，这是全球通用的，换而言之，在火星是不适用的，在我们火星，我们使用叫做GCJ-02的坐标系，腾讯地图和高德地图都使用火星坐标系，百度地图使用百度坐标系。感谢某位不知名的老司机，从地球到火星的代码:1234567891011121314151617181920212223242526272829303132333435363738394041function transformLon( x, y) &#123; ret = 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y + 0.1 * Math.sqrt(x &gt; 0 ? x : -x); ret += (20.0 * Math.sin(6.0 * x * Math.PI) + 20.0 * Math.sin(2.0 * x * Math.PI)) * 2.0 / 3.0; ret += (20.0 * Math.sin(x * Math.PI) + 40.0 * Math.sin(x / 3.0 * Math.PI)) * 2.0 / 3.0; ret += (150.0 * Math.sin(x / 12.0 * Math.PI) + 300.0 * Math.sin(x / 30.0 * Math.PI)) * 2.0 / 3.0; return ret;&#125;function transformLat(x, y) &#123; ret = -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * y + 0.2 * Math.sqrt(x &gt; 0 ? x : -x); ret += (20.0 * Math.sin(6.0 * x * Math.PI) + 20.0 * Math.sin(2.0 * x * Math.PI)) * 2.0 / 3.0; ret += (20.0 * Math.sin(y * Math.PI) + 40.0 * Math.sin(y / 3.0 * Math.PI)) * 2.0 / 3.0; ret += (160.0 * Math.sin(y / 12.0 * Math.PI) + 320 * Math.sin(y * Math.PI / 30.0)) * 2.0 / 3.0; return ret;&#125;function Earth2Mars(longitude , latitude ) &#123; const a = 6378245.0; const ee = 0.00669342162296594323; var dLat = transformLat(longitude - 105.0, latitude - 35.0); var dLon = transformLon(longitude - 105.0, latitude - 35.0); var radLat = latitude / 180.0 * Math.PI; var magic = Math.sin(radLat); magic = 1 - ee * magic * magic; var sqrtMagic = Math.sqrt(magic); dLat = (dLat * 180.0)/ ((a * (1 - ee)) / (magic * sqrtMagic) * Math.PI); dLon = (dLon * 180.0) / (a / sqrtMagic * Math.cos(radLat) * Math.PI); ret = []; ret[0] = longitude + dLon ; ret[1] = latitude + dLat ; return ret ;&#125;","tags":[{"name":"GIS","slug":"GIS","permalink":"http://yoursite.com/tags/GIS/"},{"name":"地图","slug":"地图","permalink":"http://yoursite.com/tags/地图/"}]},{"title":"nodejs使用mysql模块","date":"2017-03-09T06:15:06.000Z","path":"2017/03/09/nodejs使用mysql模块/","text":"连接模块query.js12345678910111213141516171819202122232425262728var mysql = require(&apos;mysql&apos;);var pool = mysql.createPool(&#123; host :&apos;localhost&apos;, user :&apos;user&apos;, password:&apos;password&apos;, database:&apos;database&apos;&#125;);exports.query = function ( sql , callback)&#123; pool.getConnection( function ( err , connection)&#123; console.log(&apos;getConnection Done&apos;); if(err)&#123; console.log(err); return callback(err); &#125; console.log(&quot;Querying on DB&quot;); connection.query(sql , function (error, results, fields) &#123; connection.release(); if (error) &#123; console.log(err); return callback(err); &#125; if(results.length &gt; 0 )&#123; console.log( results[0] ); &#125; return callback(error,results); &#125;); &#125;);&#125;; connection.release()把连接放回pool中","tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://yoursite.com/tags/Nodejs/"},{"name":"Mysql","slug":"Mysql","permalink":"http://yoursite.com/tags/Mysql/"}]},{"title":"ejs模板使用笔记","date":"2017-03-09T05:47:43.000Z","path":"2017/03/09/ejs模板使用笔记/","text":"&lt;% %&gt;被&lt;% %&gt;括住的内容会被ejs compiler当成javascript语句执行。使得我们可以在.ejs中使用javascript那为什么我们不直接使用 &lt;script&gt;标签呢？实际上它们存在区别，&lt;script&gt;中的内容本质还是你的html，也就是你点开页面view source能直接看到代码；相反，&lt;% %&gt;括住的内容是不会被转义成html的，它们的功能应该是辅助你书写ejs。在&lt;script&gt;中使用&lt;% %&gt;时需要注意这点。 &lt;%= %&gt; 被&lt;%= %&gt;括住的变量会被ejs转义成变量的值输出到html中。应当注意&lt;%= %&gt;不在&lt;% %&gt;中被使用 demo这是我在做一个经纬度标记到高德地图上所使用的ejs代码12345678910111213141516171819 &lt;script type=&quot;text/javascript&quot;&gt;pos = [ &lt;%=results[0].Longitude%&gt; , &lt;%=results[0].Latitude%&gt;]; var map = new AMap.Map(&apos;container&apos;,&#123; resizeEnable: true, zoom: 10, center: pos &#125;); var marker = [] ; if( !&lt;%=empty%&gt;)&#123; &lt;% for( var i = 0 ; i &lt; results.length ; i ++ )&#123;%&gt; marker[&lt;%=i%&gt;] = new AMap.Marker(&#123; icon: &quot;http://webapi.amap.com/theme/v1.3/markers/n/mark_b.png&quot;, position: [ &lt;%=results[i].Longitude%&gt; , &lt;%=results[i].Latitude%&gt; ] &#125;); marker[&lt;%=i%&gt;].setMap(map); &lt;%;&#125;%&gt; &#125; &lt;/script&gt; 用浏览器打开view source，得到的结果是1234567891011121314151617181920212223242526272829303132 &lt;script type=&quot;text/javascript&quot;&gt; pos = [ 103.89472166666667 , 30.97911]; var map = new AMap.Map(&apos;container&apos;,&#123; resizeEnable: true, zoom: 10, center: pos &#125;); var marker = [] ; if( !false)&#123; marker[0] = new AMap.Marker(&#123; icon: &quot;http://webapi.amap.com/theme/v1.3/markers/n/mark_b.png&quot;, position: [ 103.89472166666667 , 30.97911 ] &#125;); marker[0].setMap(map); marker[1] = new AMap.Marker(&#123; icon: &quot;http://webapi.amap.com/theme/v1.3/markers/n/mark_b.png&quot;, position: [ 103.89472166666667 , 30.97911 ] &#125;); marker[1].setMap(map); marker[2] = new AMap.Marker(&#123; icon: &quot;http://webapi.amap.com/theme/v1.3/markers/n/mark_b.png&quot;, position: [ 103.89463833333333 , 30.9795 ] &#125;); marker[2].setMap(map); .....省略.....&#125;&lt;/script&gt;","tags":[{"name":"Ejs","slug":"Ejs","permalink":"http://yoursite.com/tags/Ejs/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://yoursite.com/tags/Nodejs/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"Linear Regression","date":"2017-03-01T08:55:00.000Z","path":"2017/03/01/Linear-Regression/","text":"目的对于给定的训练集合(training set) x 和 y ， 其中x为m * n 的矩阵 ， y 为 m行的列向量，也就是有m个训练样本(samples) ， 每个样本有 n 个features ，我们希望能学习训练集合从而如果有一个新的输入数据 x ， 我们能预测与它对应的y的值。以房屋价格为例 ， 假设我们有 m个房屋数据，每间住房包括“住房面积”和“房间个数”作为features (此时n=2), 现在给定一间 面积为100，2间房的房屋，希望预测房屋价格 模型$$h_{\\theta}(X) = \\theta ^TX = \\theta_0 + \\theta_1x_1 + … + \\theta_nx_n$$上式中的$x$为 n*1的列向量 ，$X = [1 ; x]$ ，添加了截距项(intercept term).所以我们需要根据训练样本找到最适合的$\\theta$ Cost Function$$J(\\theta) = \\frac{1}{2}\\sum{i=1}^{n}(h\\theta(x^{(i)})-y^{(i)})^2 $$其中$x^{(i)}$ ， $y^{(i)}$为第i组样本这实际上是一个ordinary least square model Compute $\\theta$目的是找到最小化$J$的$\\theta$由于$J(\\theta$)是一个凸函数使用的方法可以是gradient descent 或者 Newton-Rhaphson’s method 。得到确定的$\\theta$以后我们就可以根据输入预测了","tags":[{"name":"Machine Leanrning","slug":"Machine-Leanrning","permalink":"http://yoursite.com/tags/Machine-Leanrning/"},{"name":"Linear Regression","slug":"Linear-Regression","permalink":"http://yoursite.com/tags/Linear-Regression/"}]},{"title":"github搭建hexo","date":"2017-01-12T15:05:55.000Z","path":"2017/01/12/github搭建hexo/","text":"这次终于弄好了个人博客，以后就可以常驻这里了，专门为了一个个人博客申请一个云服务器实在是没有必要，下面简单介绍一下在github上搭建hexo博客的经验 环境123node.jshexogit 其中node.js和git就不说了，hexo的安装1$sudo npm install hexo -g Getting started1234567$mkdir hexoblog$cd hexoblog$hexo init$npm install$git init$git config user.name &quot;your github username&quot;$git config user.email &quot;your github email&quot; 修改hexoblog\\_config.yml中的deploy为1234deploy: type: git repo:https://github.com/&lt;username&gt;/&lt;username&gt;.github.io branch:master 需要说明的有 1 github的&lt;username&gt;.github.io是默认为个人网站的，这个仓库中的文件将被当作个人网站解析，详见Github Page2 在hexo 3.0以后 type设置为git，之前的版本 type设置为github 本地测试12$hexo g #hexo generate$hexo s #hexo server &nbsp;然后访问localhost:4000，可以看到个人博客的首页了 发布到github先要安装hexo-deployer-git1$npm install hexo-deployer-git --save 发布命令：1$hexo d #hexo deploy 对应之前我们在_config.yml配置文件中修改的deploy配置，将本地文件发布到相应的仓库，所以以后每次在本地文件作出修改后的发布就是：123$hexo clean$hexo g$hexo d 使用yilia theme这个主题简洁，颜值高，移动端的支持好yilia的安装 为了让yilia的标签功能使用正常，还需要进行一些配置：首先安装hexo-generator-json-content1$npm install hexo-generator-json-content 然后修改hexoblog\\_config.yml，添加：123456789101112131415161718jsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 发布一篇post1$hexo new &quot;&lt;post name&gt;&quot; 然后修改hexoblog\\source\\_post\\&lt;post name&gt;.md用markdown写博文吧:D其中1 标签设置：tags:[tag1,tag2]2 &lt;!--more--&gt;标签以后的内容在“展开全文”以后才显示","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]